// Gestor de sesiones para evitar conflictos entre pesta√±as

class SessionManager {
  private static instance: SessionManager;
  private sessionId: string;
  private isActive: boolean = true;
  private userRole: string | null = null;
  private userInstitution: string | null = null;
  private sessionToken: string | null = null;
  private sessionUserData: any = null;
  private expectedRole: string | null = null;

  private constructor(expectedRole?: string) {
    // Generar un ID √∫nico para esta pesta√±a
    this.sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    this.expectedRole = expectedRole || null;
    this.initializeSession();
    this.setupStorageListener();
  }

  public static getInstance(expectedRole?: string): SessionManager {
    if (!SessionManager.instance) {
      SessionManager.instance = new SessionManager(expectedRole);
    } else if (expectedRole && SessionManager.instance.expectedRole !== expectedRole) {
      // Si se solicita un rol diferente, crear una nueva instancia
      console.log(`üîÑ Cambiando de rol ${SessionManager.instance.expectedRole} a ${expectedRole}`);
      SessionManager.instance = new SessionManager(expectedRole);
    }
    return SessionManager.instance;
  }

  private initializeSession() {
    // Capturar la informaci√≥n del usuario actual al inicializar y almacenarla localmente
    const userData = localStorage.getItem('user_data');
    const authToken = localStorage.getItem('auth_token');
    
    if (userData && authToken) {
      try {
        const parsedUser = JSON.parse(userData);
        const currentRole = parsedUser.Rol;
        
        // Verificar si el rol coincide con el esperado
        if (this.expectedRole && currentRole !== this.expectedRole) {
          console.warn(`‚ö†Ô∏è Rol incorrecto detectado:`, {
            expected: this.expectedRole,
            actual: currentRole,
            sessionId: this.sessionId
          });
          
          // No inicializar la sesi√≥n si el rol no coincide
          console.log('üö´ Sesi√≥n no inicializada - rol incorrecto');
          return;
        }
        
        // Almacenar localmente para esta pesta√±a
        this.sessionToken = authToken;
        this.sessionUserData = parsedUser;
        this.userRole = currentRole;
        this.userInstitution = parsedUser.C√≥digo_Instituci√≥n;
        
        // Crear una copia aislada en sessionStorage para esta pesta√±a espec√≠fica
        const sessionKey = `session_${this.sessionId}`;
        const sessionData = {
          token: authToken,
          user: parsedUser,
          role: currentRole,
          institution: parsedUser.C√≥digo_Instituci√≥n,
          timestamp: Date.now()
        };
        
        sessionStorage.setItem(sessionKey, JSON.stringify(sessionData));
        
        console.log('üîí Sesi√≥n inicializada y aislada:', {
          sessionId: this.sessionId,
          role: this.userRole,
          expectedRole: this.expectedRole,
          institution: this.userInstitution,
          hasToken: !!this.sessionToken,
          sessionStorageKey: sessionKey
        });
      } catch (error) {
        console.error('Error al parsear datos de usuario:', error);
      }
    }
  }

  private setupStorageListener() {
    // Escuchar cambios en localStorage desde otras pesta√±as
    window.addEventListener('storage', (e) => {
      console.log('üîÑ Cambio detectado en localStorage:', e.key, e.newValue);
      
      // Solo reaccionar a cambios cr√≠ticos que puedan afectar esta sesi√≥n
      if (e.key === 'auth_token' && e.newValue === null) {
        console.log('‚ö†Ô∏è Token eliminado por otra pesta√±a, pero manteniendo sesi√≥n local');
        // No hacer nada - mantener la sesi√≥n local
      } else if (e.key === 'user_data' || e.key === 'user_role') {
        console.log('‚ö†Ô∏è Datos de usuario cambiados por otra pesta√±a, pero manteniendo sesi√≥n aislada');
        // NO reaccionar a cambios de localStorage - mantener la sesi√≥n aislada
        // this.handleUserDataChange(); // Comentado para evitar conflictos
      }
    });

    // Escuchar cuando la pesta√±a se cierra
    window.addEventListener('beforeunload', () => {
      this.cleanup();
    });

    // Escuchar cuando la pesta√±a pierde el foco
    window.addEventListener('blur', () => {
      this.isActive = false;
    });

    // Escuchar cuando la pesta√±a recupera el foco
    window.addEventListener('focus', () => {
      this.isActive = true;
      this.validateSession();
    });
  }

  private handleTokenRemoval() {
    // No limpiar autom√°ticamente para evitar conflictos entre pesta√±as
    console.log('üîÑ Token eliminado por otra pesta√±a, pero manteniendo sesi√≥n local para evitar p√©rdida de contenido');
    
    // Verificar si el token realmente existe
    const token = localStorage.getItem('auth_token');
    if (!token) {
      console.log('‚ö†Ô∏è Token no encontrado - posible conflicto entre pesta√±as');
      // No limpiar autom√°ticamente, dejar que el usuario decida
    }
  }

  private handleUserDataChange() {
    const currentUserData = localStorage.getItem('user_data');
    const currentUserRole = localStorage.getItem('user_role');
    
    if (currentUserData && currentUserRole) {
      try {
        const parsedUser = JSON.parse(currentUserData);
        const newRole = parsedUser.Rol;
        const newInstitution = parsedUser.C√≥digo_Instituci√≥n;
        
        // Verificar si el usuario cambi√≥ de rol o instituci√≥n
        if (newRole !== this.userRole || newInstitution !== this.userInstitution) {
          console.log('‚ö†Ô∏è Usuario cambi√≥ de rol/instituci√≥n en otra pesta√±a:', {
            oldRole: this.userRole,
            newRole: newRole,
            oldInstitution: this.userInstitution,
            newInstitution: newInstitution,
            sessionId: this.sessionId
          });
          
          // NO actualizar autom√°ticamente - mantener la sesi√≥n original de esta pesta√±a
          console.log('üîí Manteniendo sesi√≥n original de esta pesta√±a para evitar conflictos');
            }
        } catch (error) {
        console.error('Error al procesar cambio de datos de usuario:', error);
      }
    }
  }

  private validateSession() {
    const token = localStorage.getItem('auth_token');
    const userData = localStorage.getItem('user_data');
    
    if (!token || !userData) {
      console.log('‚ö†Ô∏è Sesi√≥n inv√°lida detectada, pero manteniendo datos para evitar p√©rdida de contenido');
      // No limpiar autom√°ticamente para evitar p√©rdida de contenido
      // El usuario puede decidir cu√°ndo cerrar sesi√≥n
    } else {
      console.log('‚úÖ Sesi√≥n v√°lida detectada');
    }
  }

  private clearSession() {
    // Limpiar solo la sesi√≥n de esta pesta√±a espec√≠fica
    const sessionKey = `session_${this.sessionId}`;
    sessionStorage.removeItem(sessionKey);
    
    // Solo limpiar localStorage si esta es la √∫ltima pesta√±a activa
    // (esto se puede mejorar con un sistema de conteo de pesta√±as)
    localStorage.removeItem('auth_token');
    localStorage.removeItem('user_data');
    localStorage.removeItem('user_role');
    
    // Limpiar datos locales
    this.sessionToken = null;
    this.sessionUserData = null;
    this.userRole = null;
    this.userInstitution = null;
    
    console.log('üßπ Sesi√≥n limpiada localmente y de sessionStorage');
  }

  public clearSessionManually() {
    this.clearSession();
  }

  public isSessionValid(): boolean {
    // Usar los datos locales de la sesi√≥n para validar
    const hasData = !!(this.sessionToken && this.sessionUserData);
    
    // Si hay un rol esperado, verificar que coincida
    if (this.expectedRole && this.userRole !== this.expectedRole) {
      console.warn('‚ö†Ô∏è Sesi√≥n inv√°lida - rol no coincide:', {
        expected: this.expectedRole,
        actual: this.userRole
      });
      return false;
    }
    
    return hasData;
  }

  public getSessionInfo() {
    return {
      sessionId: this.sessionId,
      isActive: this.isActive,
      isValid: this.isSessionValid(),
      expectedRole: this.expectedRole,
      actualRole: this.userRole
    };
  }

  public forceRefresh() {
    this.refreshSession();
    console.log('üîÑ Sesi√≥n forzada a refrescar');
  }

  public getSessionUserRole(): string | null {
    return this.userRole;
  }

  public getSessionUserInstitution(): string | null {
    return this.userInstitution;
  }

  public isSessionForRole(role: string): boolean {
    return this.userRole === role;
  }

  public isSessionForInstitution(institution: string): boolean {
    return this.userInstitution === institution;
  }

  public forceSessionUpdate() {
    // Forzar la actualizaci√≥n de la sesi√≥n desde localStorage
    const userData = localStorage.getItem('user_data');
    const authToken = localStorage.getItem('auth_token');
    
    if (userData && authToken) {
      try {
        const parsedUser = JSON.parse(userData);
        this.sessionToken = authToken;
        this.sessionUserData = parsedUser;
        this.userRole = parsedUser.Rol;
        this.userInstitution = parsedUser.C√≥digo_Instituci√≥n;
        
        console.log('üîÑ Sesi√≥n forzada a actualizar:', {
          sessionId: this.sessionId,
          role: this.userRole,
          institution: this.userInstitution
        });
      } catch (error) {
        console.error('Error al forzar actualizaci√≥n de sesi√≥n:', error);
      }
    }
  }

  private cleanup() {
    // Limpiar listeners y recursos
    this.isActive = false;
  }

  public getSessionId(): string {
    return this.sessionId;
  }

  public isSessionActive(): boolean {
    return this.isActive;
  }

  public refreshSession() {
    // Marcar la sesi√≥n como activa
    this.isActive = true;
    console.log('üîÑ Sesi√≥n refrescada para pesta√±a:', this.sessionId);
  }

  // M√©todos para compatibilidad con authUtils
  public clearCurrentSession() {
    this.clearSession();
  }

  public getCurrentToken(): string | null {
    // Usar el token local de la sesi√≥n para evitar conflictos entre pesta√±as
    return this.sessionToken;
  }

  public getCurrentUser(): any {
    // Usar los datos locales de la sesi√≥n para evitar conflictos entre pesta√±as
    return this.sessionUserData;
  }

  public getCurrentRole(): string | null {
    // Usar el rol local de la sesi√≥n para evitar conflictos entre pesta√±as
    return this.userRole;
  }

  public hasValidSession(): boolean {
    return this.isSessionValid();
  }

  public setSession(token: string, user: any, role: string) {
    // Actualizar localStorage
    localStorage.setItem('auth_token', token);
    localStorage.setItem('user_data', JSON.stringify(user));
    localStorage.setItem('user_role', role);
    
    // Actualizar datos locales de la sesi√≥n
    this.sessionToken = token;
    this.sessionUserData = user;
    this.userRole = role;
    this.userInstitution = user.C√≥digo_Instituci√≥n;
    
    this.refreshSession();
    console.log('‚úÖ Sesi√≥n establecida y aislada:', { 
      token: token.substring(0, 20) + '...', 
      role,
      sessionId: this.sessionId
    });
  }
}

// Funciones de conveniencia para compatibilidad
export const getCurrentToken = () => sessionManager.getCurrentToken();
export const getCurrentUser = () => sessionManager.getCurrentUser();
export const getCurrentRole = () => sessionManager.getCurrentRole();
export const hasValidSession = () => sessionManager.hasValidSession();
export const setSession = (token: string, user: any, role: string) => sessionManager.setSession(token, user, role);
export const forceSessionUpdate = () => sessionManager.forceSessionUpdate();

// Funciones espec√≠ficas por rol
export const getMaestroSession = () => SessionManager.getInstance('Maestro');
export const getAlumnoSession = () => SessionManager.getInstance('Alumno');
export const getDirectorSession = () => SessionManager.getInstance('Director');
export const getSupervisorSession = () => SessionManager.getInstance('Supervisor');

export const sessionManager = SessionManager.getInstance();
export default sessionManager;